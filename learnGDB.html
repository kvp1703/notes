<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GDB Debugging Master</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 0;
            min-height: 600px;
        }

        .sidebar {
            background: #f8f9fa;
            border-right: 2px solid #dee2e6;
            padding: 20px;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .difficulty-section {
            margin-bottom: 30px;
        }

        .difficulty-header {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .difficulty-header.beginner {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #1a5f3f;
        }

        .difficulty-header.medium {
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            color: white;
        }

        .difficulty-header.hard {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #8b0000;
        }

        .exercise-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            border: none;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            font-size: 0.95em;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .exercise-btn:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .exercise-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
        }

        .content-area {
            padding: 40px;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .exercise-header {
            margin-bottom: 25px;
        }

        .exercise-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .exercise-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .badge {
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            text-transform: uppercase;
        }

        .badge.beginner {
            background: #d4edda;
            color: #155724;
        }

        .badge.medium {
            background: #fff3cd;
            color: #856404;
        }

        .badge.hard {
            background: #f8d7da;
            color: #721c24;
        }

        .code-section {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .code-label {
            color: #61dafb;
            font-weight: bold;
            font-size: 1.1em;
        }

        .copy-btn {
            background: #61dafb;
            color: #1e1e1e;
            border: none;
            padding: 8px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .copy-btn:hover {
            background: #4fa8c5;
            transform: scale(1.05);
        }

        pre {
            margin: 0;
            overflow-x: auto;
        }

        code {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .keyword { color: #569cd6; }
        .function { color: #dcdcaa; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .number { color: #b5cea8; }
        .type { color: #4ec9b0; }

        .question-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            color: white;
        }

        .question-label {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .question-text {
            font-size: 1.1em;
            line-height: 1.6;
        }

        .actions {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
        }

        .action-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hint-btn {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #8b4513;
        }

        .answer-btn {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #2c3e50;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .reveal-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 5px solid;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .reveal-section.show {
            display: block;
            animation: slideDown 0.4s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .reveal-section.hint {
            border-left-color: #ff9800;
        }

        .reveal-section.answer {
            border-left-color: #4caf50;
        }

        .reveal-header {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .reveal-content {
            font-size: 1.05em;
            line-height: 1.7;
            color: #555;
        }

        .commands {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: monospace;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .welcome-screen {
            text-align: center;
            padding: 60px 40px;
        }

        .welcome-screen h2 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .welcome-screen p {
            font-size: 1.2em;
            color: #555;
            line-height: 1.8;
            max-width: 800px;
            margin: 0 auto 30px;
        }

        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 40px;
        }

        .feature-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
        }

        .feature-card h3 {
            margin-bottom: 10px;
            font-size: 1.3em;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🔧 GDB Debugging Master</h1>
            <p class="subtitle">Master debugging with 30 hands-on exercises from beginner to expert</p>
        </header>

        <div class="main-content">
            <aside class="sidebar">
                <div class="difficulty-section">
                    <div class="difficulty-header beginner">🌱 Beginner (1-10)</div>
                    <div id="beginner-exercises"></div>
                </div>

                <div class="difficulty-section">
                    <div class="difficulty-header medium">⚡ Medium (11-20)</div>
                    <div id="medium-exercises"></div>
                </div>

                <div class="difficulty-section">
                    <div class="difficulty-header hard">🔥 Hard (21-30)</div>
                    <div id="hard-exercises"></div>
                </div>
            </aside>

            <main class="content-area" id="content-area">
                <div class="welcome-screen">
                    <h2>Welcome to GDB Debugging Master!</h2>
                    <p>This interactive platform provides 30 carefully crafted C programming exercises designed to teach you GDB debugging from the ground up. Each exercise includes real code that you'll compile, run, and debug on your machine.</p>
                    <p><strong>How it works:</strong> Select an exercise from the sidebar, copy the C code, compile it with debugging symbols (<code>gcc -g -pthread file.c -o program</code>), and use GDB to answer the question. Check your answer and get hints when needed!</p>
                    
                    <div class="features">
                        <div class="feature-card">
                            <h3>10 Beginner</h3>
                            <p>Master the basics: breakpoints, stepping, and inspection</p>
                        </div>
                        <div class="feature-card">
                            <h3>10 Medium</h3>
                            <p>Explore watchpoints, conditions, and memory analysis</p>
                        </div>
                        <div class="feature-card">
                            <h3>10 Hard</h3>
                            <p>Conquer multithreading, complex data structures, and race conditions</p>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        const exercises = [
            // BEGINNER EXERCISES (1-10)
            {
                id: 1,
                difficulty: 'beginner',
                title: 'First Breakpoint',
                code: `#include <stdio.h>

int calculate_sum(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = 15;
    int y = 27;
    int sum = calculate_sum(x, y);
    printf("Sum: %d\\n", sum);
    return 0;
}`,
                question: 'Set a breakpoint at line 4 (inside calculate_sum). Run the program. What is the value stored in register %rdi (x86-64) or $a0 (other architectures) when you hit the breakpoint for the first time?',
                hint: 'Use "break 4" to set the breakpoint, then "run" to start. Use "info registers rdi" or "print $rdi" to see the register value. This register holds the first function argument.',
                answer: '15 (0xf in hexadecimal). The %rdi register contains the first argument to calculate_sum, which is the value of x passed from main.'
            },
            {
                id: 2,
                difficulty: 'beginner',
                title: 'Variable Inspection',
                code: `#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;
    ptr += 2;
    int value = *ptr;
    printf("Value: %d\\n", value);
    return 0;
}`,
                question: 'Set a breakpoint at line 7 (int value = *ptr;). When you hit the breakpoint, what memory address does ptr point to, and what value is at that address?',
                hint: 'Use "break 7", then "run". Use "print ptr" to see the address, and "print *ptr" to see the value. Remember ptr was incremented by 2 from the array base.',
                answer: 'ptr points to &arr[2], and the value at that address is 30. The pointer arithmetic ptr += 2 moved the pointer 2 integers forward from arr[0].'
            },
            {
                id: 3,
                difficulty: 'beginner',
                title: 'Step Through Loop',
                code: `#include <stdio.h>

int main() {
    int total = 0;
    for(int i = 1; i <= 5; i++) {
        total += i * 2;
    }
    printf("Total: %d\\n", total);
    return 0;
}`,
                question: 'Set a breakpoint at line 6 (inside the loop). Run and hit continue twice. On the third hit of the breakpoint, what are the values of i and total?',
                hint: 'Use "break 6", then "run". Use "continue" (or "c") to hit the breakpoint again. After 2 continues, use "print i" and "print total". The loop has executed twice by then.',
                answer: 'i = 3, total = 6. After the first iteration: i=1, total=2. After the second: i=2, total=6. The third hit is when i=3 before that iteration executes.'
            },
            {
                id: 4,
                difficulty: 'beginner',
                title: 'Function Return Value',
                code: `#include <stdio.h>

int multiply(int a, int b) {
    int product = a * b;
    return product;
}

int main() {
    int result = multiply(7, 8);
    printf("Result: %d\\n", result);
    return 0;
}`,
                question: 'Set a breakpoint at line 5 (return statement). Run the program. What value is in the %rax register (or $v0 register) just before the function returns?',
                hint: 'Use "break 5", then "run". The %rax (or $v0) register holds the return value. Use "info registers rax" or "print $rax" to check its value.',
                answer: '56 (0x38 in hex). The %rax register contains the return value of the function, which is 7 * 8 = 56.'
            },
            {
                id: 5,
                difficulty: 'beginner',
                title: 'Stack Frame Analysis',
                code: `#include <stdio.h>

void inner_function(int x) {
    int local_var = x * 3;
    printf("Inner: %d\\n", local_var);
}

void outer_function(int y) {
    int outer_var = y + 10;
    inner_function(outer_var);
}

int main() {
    outer_function(5);
    return 0;
}`,
                question: 'Set a breakpoint at line 4 (inside inner_function). Run the program. Use the backtrace command. What is the value of variable "y" in the outer_function frame?',
                hint: 'Use "break 4", "run", then "backtrace" (or "bt") to see the call stack. Use "frame 1" to switch to outer_function\'s frame, then "print y" to see its value.',
                answer: 'y = 5. You can navigate frames with "frame N" command and inspect variables from different stack frames. The outer_function was called with y=5 from main.'
            },
            {
                id: 6,
                difficulty: 'beginner',
                title: 'Array Bounds',
                code: `#include <stdio.h>

int main() {
    int numbers[4] = {100, 200, 300, 400};
    int index = 0;
    while(index < 4) {
        printf("numbers[%d] = %d\\n", index, numbers[index]);
        index++;
    }
    return 0;
}`,
                question: 'Set a breakpoint at line 7 (the printf line). Run and continue until index equals 2. At that point, what is the memory address of numbers[2], and what instruction will execute after the current line?',
                hint: 'Use "break 7", "run", then "continue" twice. Use "print &numbers[2]" for the address. Use "disassemble" or "x/i $pc" to see current instruction, or "next" and check "disassemble".',
                answer: 'The address will be (base address of numbers + 8 bytes). The next instruction will be the index++ operation at line 8. Use "info line 8" to see the exact instruction address.'
            },
            {
                id: 7,
                difficulty: 'beginner',
                title: 'Pointer Dereferencing',
                code: `#include <stdio.h>

int main() {
    int value = 42;
    int *p1 = &value;
    int **p2 = &p1;
    
    **p2 = 84;
    
    printf("Value: %d\\n", value);
    return 0;
}`,
                question: 'Set a breakpoint at line 8 (**p2 = 84;). When you hit it, what are the addresses stored in p1 and p2, and what value does each point to?',
                hint: 'Use "break 8", "run". Use "print p1" and "print p2" for addresses. Use "print *p1" and "print *p2" to dereference. p2 points to p1, p1 points to value.',
                answer: 'p1 contains the address of value (&value), and *p1 = 42. p2 contains the address of p1 (&p1), and *p2 equals the contents of p1 (which is &value). **p2 would dereference twice to get 42.'
            },
            {
                id: 8,
                difficulty: 'beginner',
                title: 'Conditional Breakpoint',
                code: `#include <stdio.h>

int main() {
    for(int i = 0; i < 10; i++) {
        int square = i * i;
        printf("%d squared = %d\\n", i, square);
    }
    return 0;
}`,
                question: 'Set a conditional breakpoint at line 5 that only triggers when i equals 7. What is the value of the square variable when this breakpoint is hit?',
                hint: 'Use "break 5 if i == 7", then "run". When it stops, use "print square". The breakpoint only triggers when the condition is true.',
                answer: 'square = 49. The conditional breakpoint only stops execution when i equals 7, at which point square is calculated as 7 * 7 = 49.'
            },
            {
                id: 9,
                difficulty: 'beginner',
                title: 'Structure Member Access',
                code: `#include <stdio.h>

struct Point {
    int x;
    int y;
};

int main() {
    struct Point p = {15, 25};
    struct Point *ptr = &p;
    ptr->x = 30;
    ptr->y = 40;
    printf("Point: (%d, %d)\\n", p.x, p.y);
    return 0;
}`,
                question: 'Set a breakpoint at line 12 (ptr->y = 40;). When hit, what is the memory offset (in bytes) between the addresses of p.x and p.y?',
                hint: 'Use "break 12", "run". Use "print &p.x" and "print &p.y" to get addresses. Subtract them. Integers are typically 4 bytes.',
                answer: '4 bytes. The y member comes immediately after x in the structure. Since x is an int (4 bytes), y is located 4 bytes after x in memory.'
            },
            {
                id: 10,
                difficulty: 'beginner',
                title: 'Step vs Next',
                code: `#include <stdio.h>

int helper(int n) {
    return n * 5;
}

int main() {
    int a = 10;
    int b = helper(a);
    int c = b + 20;
    printf("Result: %d\\n", c);
    return 0;
}`,
                question: 'Set a breakpoint at line 9 (int b = helper(a);). When hit, use "step" command. What line number are you on after the step command, and what function are you in?',
                hint: 'Use "break 9", "run", then "step" (or "s"). The "step" command enters into function calls. Use "where" or "frame" to see current location.',
                answer: 'You will be at line 4 (return n * 5;) inside the helper function. The "step" command steps into functions, unlike "next" which would step over them.'
            },

            // MEDIUM EXERCISES (11-20)
            {
                id: 11,
                difficulty: 'medium',
                title: 'Watchpoint on Variable',
                code: `#include <stdio.h>

int global_counter = 0;

void increment() {
    global_counter++;
}

void process_data(int iterations) {
    for(int i = 0; i < iterations; i++) {
        global_counter += 2;
        if(i % 3 == 0) {
            increment();
        }
    }
}

int main() {
    process_data(7);
    printf("Counter: %d\\n", global_counter);
    return 0;
}`,
                question: 'Set a watchpoint on global_counter. Run the program. How many times does the watchpoint trigger, and what is the value of global_counter when it reaches 10 for the first time?',
                hint: 'Use "watch global_counter" to set the watchpoint. Then "run". The program will stop every time global_counter changes. Use "continue" to proceed and "print global_counter" to check value.',
                answer: 'The watchpoint triggers 10 times total (7 iterations * 2 modifications each + 3 increment calls). global_counter reaches 10 after the 4th iteration (i=3): iterations 0-3 add 8 (2*4), plus 2 increment calls add 2, totaling 10.'
            },
            {
                id: 12,
                difficulty: 'medium',
                title: 'Memory Examination',
                code: `#include <stdio.h>
#include <string.h>

int main() {
    char buffer[20];
    strcpy(buffer, "GDB");
    int magic = 0xDEADBEEF;
    char more[10] = "Testing";
    
    printf("Done\\n");
    return 0;
}`,
                question: 'Set a breakpoint at line 10 (printf line). When hit, examine 40 bytes of memory starting from the address of buffer in hexadecimal format. What is the 4-byte value stored at the location of the magic variable?',
                hint: 'Use "break 10", "run". Use "x/40xb &buffer" to examine bytes in hex. Find where 0xDEADBEEF appears. Due to little-endian, it appears as EF BE AD DE.',
                answer: '0xDEADBEEF (appears as EF BE AD DE in little-endian byte order). Use "x/1xw &magic" to see it as a word, or find it in the memory dump as bytes EF BE AD DE.'
            },
            {
                id: 13,
                difficulty: 'medium',
                title: 'Dynamic Memory Tracking',
                code: `#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node* create_node(int value) {
    Node *n = (Node*)malloc(sizeof(Node));
    n->data = value;
    n->next = NULL;
    return n;
}

int main() {
    Node *head = create_node(100);
    head->next = create_node(200);
    head->next->next = create_node(300);
    
    Node *current = head->next;
    
    printf("Data: %d\\n", current->data);
    return 0;
}`,
                question: 'Set a breakpoint at line 22 (printf line). When hit, what is the memory address of the third node (data=300), and how many bytes separate it from the second node in memory?',
                hint: 'Use "break 22", "run". Use "print head->next->next" to get third node address. Use "print head->next" for second node. Subtract addresses. malloc may not allocate consecutively.',
                answer: 'The third node address can be found with "print head->next->next". The separation depends on malloc\'s allocation but is typically 16-32 bytes apart (malloc adds metadata). Use address subtraction to get exact bytes.'
            },
            {
                id: 14,
                difficulty: 'medium',
                title: 'Backtrace with Arguments',
                code: `#include <stdio.h>

int level3(int a, int b, int c) {
    int result = a * b + c;
    return result;
}

int level2(int x, int y) {
    int z = x + y;
    return level3(x, y, z);
}

int level1(int value) {
    return level2(value, value * 2);
}

int main() {
    int answer = level1(5);
    printf("Answer: %d\\n", answer);
    return 0;
}`,
                question: 'Set a breakpoint at line 4 (inside level3). Run the program. When hit, print a full backtrace with arguments. What are the values of all three arguments passed to level2?',
                hint: 'Use "break 4", "run". Use "backtrace full" or "bt full" to see all frames with arguments and local variables. Look for the level2 frame.',
                answer: 'In level2 frame: x = 5, y = 10. These values come from level1(5) which calls level2(5, 5*2). Use "frame 1" and "info args" to see arguments clearly.'
            },
            {
                id: 15,
                difficulty: 'medium',
                title: 'Reverse Debugging Simulation',
                code: `#include <stdio.h>

int fibonacci(int n) {
    if(n <= 1) return n;
    int a = 0, b = 1, temp;
    for(int i = 2; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

int main() {
    int result = fibonacci(8);
    printf("Fib(8) = %d\\n", result);
    return 0;
}`,
                question: 'Set a breakpoint at line 7 (temp = a + b;). Run and continue until i equals 5. At that moment, what are the values of a, b, and temp (before temp is assigned)?',
                hint: 'Use "break 7", "run". Use "continue" multiple times or "continue 3" to skip hits. When i==5, "print a", "print b", "print temp". Track the Fibonacci sequence.',
                answer: 'When i=5 at line 7: a = 2, b = 3, temp = 5 (previous iteration value). After this line executes, temp becomes 5 (2+3), then a becomes 3, then b becomes 5.'
            },
            {
                id: 16,
                difficulty: 'medium',
                title: 'Signal Handling',
                code: `#include <stdio.h>
#include <signal.h>
#include <unistd.h>

int signal_count = 0;

void signal_handler(int signum) {
    signal_count++;
    printf("Signal caught! Count: %d\\n", signal_count);
}

int main() {
    signal(SIGINT, signal_handler);
    for(int i = 0; i < 5; i++) {
        printf("Iteration %d\\n", i);
        sleep(1);
    }
    printf("Total signals: %d\\n", signal_count);
    return 0;
}`,
                question: 'Compile and run this in GDB. While running, send SIGINT (Ctrl+C in another terminal with kill -INT <pid>). Set a breakpoint in signal_handler at line 8. What is the instruction pointer ($pc or $rip) value when the breakpoint is hit inside the signal handler?',
                hint: 'Use "run", then send signal from another terminal. Or use "handle SIGINT stop" then "signal SIGINT" in GDB. Use "break 8". When hit, "print $rip" or "print $pc" shows instruction pointer.',
                answer: 'The $rip/$pc will point to an address within the signal_handler function, specifically at line 8. The exact value varies but use "info registers rip" or "x/i $pc" to see it. GDB shows: <address> in signal_handler.'
            },
            {
                id: 17,
                difficulty: 'medium',
                title: 'Assembly Instruction Analysis',
                code: `#include <stdio.h>

int complex_calc(int x, int y) {
    int result = (x << 2) + (y >> 1) - (x & y);
    return result;
}

int main() {
    int a = 12;
    int b = 20;
    int answer = complex_calc(a, b);
    printf("Answer: %d\\n", answer);
    return 0;
}`,
                question: 'Set a breakpoint at the start of complex_calc function. Run the program. Use disassemble command on complex_calc. What assembly instruction is used for the left shift operation (x << 2)?',
                hint: 'Use "break complex_calc", "run", then "disassemble complex_calc". Look for shift instructions like "shl" or "sal" (shift left). The operand will be 2 or $0x2.',
                answer: 'The instruction is "shl" (shift left) or "sal" (shift arithmetic left) with operand 2. It might appear as "shl $0x2, %eax" or similar depending on optimization. This multiplies x by 4.'
            },
            {
                id: 18,
                difficulty: 'medium',
                title: 'Multi-dimensional Array',
                code: `#include <stdio.h>

int main() {
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    int *ptr = &matrix[0][0];
    ptr += 7;
    
    int value = *ptr;
    printf("Value: %d\\n", value);
    return 0;
}`,
                question: 'Set a breakpoint at line 13 (int value = *ptr;). When hit, what are the row and column indices that ptr is pointing to in the matrix, and what is the byte offset from the start of the matrix?',
                hint: 'Use "break 13", "run". matrix[0][0] starts at index 0. ptr += 7 moves 7 integers forward. Count: matrix[1][3] is the 7th element (0-indexed). Use "print ptr - &matrix[0][0]" for offset.',
                answer: 'ptr points to matrix[1][3] (value = 8). It is 7 elements from start: matrix[0][0-3] = 4 elements, matrix[1][0-2] = 3 elements, matrix[1][3] = 1 element. Byte offset = 7 * 4 = 28 bytes.'
            },
            {
                id: 19,
                difficulty: 'medium',
                title: 'Function Pointer Debugging',
                code: `#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

typedef int (*operation)(int, int);

int main() {
    operation ops[3] = {add, subtract, multiply};
    int x = 10, y = 5;
    
    for(int i = 0; i < 3; i++) {
        int result = ops[i](x, y);
        printf("Result: %d\\n", result);
    }
    return 0;
}`,
                question: 'Set a breakpoint at line 14 (int result = ops[i](x, y);). Run and continue until i equals 2. What is the memory address stored in ops[2], and which function does it point to?',
                hint: 'Use "break 14", "run", then "continue" twice to reach i=2. Use "print ops[2]" to see the function pointer address. Use "info symbol ops[2]" or "print multiply" to confirm.',
                answer: 'ops[2] contains the address of the multiply function. Use "print ops[2]" to see the address (e.g., 0x401234). Use "info symbol <address>" to confirm it points to multiply, or "print multiply" to compare addresses.'
            },
            {
                id: 20,
                difficulty: 'medium',
                title: 'Recursive Call Stack',
                code: `#include <stdio.h>

int factorial(int n, int accumulator) {
    if(n <= 1) {
        return accumulator;
    }
    return factorial(n - 1, n * accumulator);
}

int main() {
    int result = factorial(5, 1);
    printf("Factorial: %d\\n", result);
    return 0;
}`,
                question: 'Set a breakpoint at line 4 (if statement in factorial). Run the program. When the breakpoint is first hit with n equals 2, print a backtrace. How many stack frames are there, and what is the value of accumulator in the frame where n equals 4?',
                hint: 'Use "break 4", "run", then "continue" until n==2. Use "backtrace" or "bt" to see all frames. Use "frame N" to select frames and "info locals" to see n and accumulator values in each frame.',
                answer: 'There are 5 frames (main + 4 recursive calls for n=5,4,3,2). When n=2, look at the frame where n=4: use "frame 3" then "info locals". The accumulator in that frame is 20 (5*4*1 from n=5 down to n=4).'
            },

            // HARD EXERCISES (21-30)
            {
                id: 21,
                difficulty: 'hard',
                title: 'Basic Multithreading',
                code: `#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

int shared_counter = 0;

void* thread_function(void* arg) {
    int thread_id = *(int*)arg;
    for(int i = 0; i < 3; i++) {
        shared_counter++;
        printf("Thread %d: counter = %d\\n", thread_id, shared_counter);
        usleep(100000);
    }
    return NULL;
}

int main() {
    pthread_t threads[3];
    int ids[3] = {1, 2, 3};
    
    for(int i = 0; i < 3; i++) {
        pthread_create(&threads[i], NULL, thread_function, &ids[i]);
    }
    
    for(int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }
    
    printf("Final counter: %d\\n", shared_counter);
    return 0;
}`,
                question: 'Compile with -pthread. Set a breakpoint at line 10 (shared_counter++;). Run until it hits. Use "info threads" to list all threads. Switch to thread 2 using "thread 2". What is the value of thread_id in thread 2\'s context?',
                hint: 'Use "break 10", "run". Use "info threads" to see all threads (4 total: main + 3 workers). Use "thread 2" to switch. Use "print thread_id" to see the value in that thread\'s stack frame.',
                answer: 'thread_id will be 1, 2, or 3 depending on which thread is "thread 2" in GDB\'s numbering (GDB assigns thread IDs). Use "thread 2", "bt", and "print thread_id" to see the actual thread_id variable value for that thread.'
            },
            {
                id: 22,
                difficulty: 'hard',
                title: 'Race Condition Detection',
                code: `#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>

#define NUM_THREADS 4
#define INCREMENTS 1000

int global_sum = 0;

void* increment_sum(void* arg) {
    for(int i = 0; i < INCREMENTS; i++) {
        int temp = global_sum;
        temp++;
        global_sum = temp;
    }
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    
    for(int i = 0; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, increment_sum, NULL);
    }
    
    for(int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    printf("Expected: %d, Got: %d\\n", NUM_THREADS * INCREMENTS, global_sum);
    return 0;
}`,
                question: 'Set a watchpoint on global_sum. Run the program. Due to race conditions, global_sum will be less than expected. When the watchpoint hits during a race condition, what is the difference between the expected sequential value and the actual value being written?',
                hint: 'Use "watch global_sum", "run". The watchpoint will trigger many times. Track occurrences where multiple threads read the same temp value. The race occurs at lines 12-14. Expected: sequential 1,2,3... Actual: some values repeat.',
                answer: 'The race condition causes lost updates. Multiple threads may read the same global_sum value, increment it, and write back the same result. The difference varies but typically you\'ll see writes that don\'t increment by 1 (e.g., writing 5 when it was already 5).'
            },
            {
                id: 23,
                difficulty: 'hard',
                title: 'Mutex Deadlock Analysis',
                code: `#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

void* thread1_func(void* arg) {
    pthread_mutex_lock(&mutex1);
    printf("Thread 1: Locked mutex1\\n");
    sleep(1);
    printf("Thread 1: Trying to lock mutex2\\n");
    pthread_mutex_lock(&mutex2);
    printf("Thread 1: Locked mutex2\\n");
    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);
    return NULL;
}

void* thread2_func(void* arg) {
    pthread_mutex_lock(&mutex2);
    printf("Thread 2: Locked mutex2\\n");
    sleep(1);
    printf("Thread 2: Trying to lock mutex1\\n");
    pthread_mutex_lock(&mutex1);
    printf("Thread 2: Locked mutex1\\n");
    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, thread1_func, NULL);
    pthread_create(&t2, NULL, thread2_func, NULL);
    
    sleep(5);
    printf("Potential deadlock scenario\\n");
    
    pthread_cancel(t1);
    pthread_cancel(t2);
    return 0;
}`,
                question: 'Run this program in GDB (it will deadlock). After a few seconds, use Ctrl+C to interrupt. Use "info threads" and "thread apply all bt" to see all backtraces. Which line numbers are the two threads blocked at, and what mutex is each trying to acquire?',
                hint: 'Use "run", wait for deadlock (3+ seconds), then Ctrl+C. Use "info threads" to see thread states. Use "thread apply all bt" to see all backtraces. Look for pthread_mutex_lock calls.',
                answer: 'Thread 1 is blocked at line 13 trying to lock mutex2 (inside pthread_mutex_lock(&mutex2)). Thread 2 is blocked at line 25 trying to lock mutex1 (inside pthread_mutex_lock(&mutex1)). This is a classic deadlock pattern.'
            },
            {
                id: 24,
                difficulty: 'hard',
                title: 'Complex Data Structure Navigation',
                code: `#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Employee {
    int id;
    char name[50];
    float salary;
    struct Employee *manager;
    struct Employee **subordinates;
    int subordinate_count;
} Employee;

Employee* create_employee(int id, const char* name, float salary) {
    Employee *e = malloc(sizeof(Employee));
    e->id = id;
    strcpy(e->name, name);
    e->salary = salary;
    e->manager = NULL;
    e->subordinates = NULL;
    e->subordinate_count = 0;
    return e;
}

void add_subordinate(Employee *manager, Employee *subordinate) {
    manager->subordinates = realloc(manager->subordinates, 
                                    (manager->subordinate_count + 1) * sizeof(Employee*));
    manager->subordinates[manager->subordinate_count] = subordinate;
    subordinate->manager = manager;
    manager->subordinate_count++;
}

int main() {
    Employee *ceo = create_employee(1, "Alice", 200000);
    Employee *cto = create_employee(2, "Bob", 150000);
    Employee *dev1 = create_employee(3, "Charlie", 100000);
    Employee *dev2 = create_employee(4, "Diana", 105000);
    
    add_subordinate(ceo, cto);
    add_subordinate(cto, dev1);
    add_subordinate(cto, dev2);
    
    printf("Organization built\\n");
    return 0;
}`,
                question: 'Set a breakpoint at line 42 (printf line). When hit, navigate to dev2. What is the salary of dev2\'s manager\'s manager (CEO), and what is the memory address of the CEO\'s subordinates array?',
                hint: 'Use "break 42", "run". Use "print dev2->manager->manager->salary" for CEO salary. Use "print dev2->manager->manager->subordinates" for array address. Navigate pointers step by step.',
                answer: 'The CEO\'s salary is 200000.0. The subordinates array address can be found with "print ceo->subordinates" or "print dev2->manager->manager->subordinates". It will be a heap address like 0x555555756xxx.'
            },
            {
                id: 25,
                difficulty: 'hard',
                title: 'Thread-Local Storage',
                code: `#include <stdio.h>
#include <pthread.h>

__thread int thread_local_var = 0;
int global_var = 0;

void* thread_work(void* arg) {
    int thread_num = *(int*)arg;
    thread_local_var = thread_num * 100;
    global_var += thread_num;
    
    printf("Thread %d: TLS=%d, Global=%d\\n", 
           thread_num, thread_local_var, global_var);
    
    for(int i = 0; i < 5; i++) {
        thread_local_var += i;
    }
    
    printf("Thread %d: Final TLS=%d\\n", thread_num, thread_local_var);
    return NULL;
}

int main() {
    pthread_t threads[3];
    int ids[3] = {1, 2, 3};
    
    for(int i = 0; i < 3; i++) {
        pthread_create(&threads[i], NULL, thread_work, &ids[i]);
    }
    
    for(int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }
    
    return 0;
}`,
                question: 'Set a breakpoint at line 19 (second printf). When hit in any thread, check the value of thread_local_var. Switch to a different thread. What is the value of thread_local_var in that other thread, and why is it different?',
                hint: 'Use "break 19", "run". Use "info threads" to see threads. Use "thread 2" to switch threads. Use "print thread_local_var" in each thread. TLS variables have separate instances per thread.',
                answer: 'Each thread has its own copy of thread_local_var. In thread 1 it will be 110 (100 + 0+1+2+3+4), in thread 2 it will be 210, in thread 3 it will be 310. The __thread keyword creates thread-local storage, so each thread has a separate instance of the variable.'
            },
            {
                id: 26,
                difficulty: 'hard',
                title: 'Producer-Consumer with Condition Variables',
                code: `#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int count = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void* producer(void* arg) {
    for(int i = 0; i < 10; i++) {
        pthread_mutex_lock(&mutex);
        while(count == BUFFER_SIZE) {
            pthread_cond_wait(&not_full, &mutex);
        }
        buffer[count++] = i;
        printf("Produced: %d, Count: %d\\n", i, count);
        pthread_cond_signal(&not_empty);
        pthread_mutex_unlock(&mutex);
        usleep(100000);
    }
    return NULL;
}

void* consumer(void* arg) {
    for(int i = 0; i < 10; i++) {
        pthread_mutex_lock(&mutex);
        while(count == 0) {
            pthread_cond_wait(&not_empty, &mutex);
        }
        int item = buffer[--count];
        printf("Consumed: %d, Count: %d\\n", item, count);
        pthread_cond_signal(&not_full);
        pthread_mutex_unlock(&mutex);
        usleep(150000);
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);
    return 0;
}`,
                question: 'Set a breakpoint at line 17 (pthread_cond_wait in producer). Run until it hits. At that moment, what is the value of count, and use "print mutex.__data.__lock" to check if the mutex is locked (1) or unlocked (0)?',
                hint: 'Use "break 17", "run". When pthread_cond_wait is called, count should be BUFFER_SIZE (5). Use "print count" and "print mutex" to examine the mutex structure. The mutex is actually unlocked during the wait.',
                answer: 'count = 5 (BUFFER_SIZE). When pthread_cond_wait is entered, the mutex is automatically released by the function, so mutex.__data.__lock will be 0 (unlocked). The thread is waiting for the condition variable to be signaled.'
            },
            {
                id: 27,
                difficulty: 'hard',
                title: 'Memory Corruption Detection',
                code: `#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char name[20];
    int *data;
    int data_size;
} Record;

void process_record(Record *rec) {
    rec->data = malloc(rec->data_size * sizeof(int));
    for(int i = 0; i <= rec->data_size; i++) {  // Bug: <= instead of <
        rec->data[i] = i * 10;
    }
}

int main() {
    Record r1;
    r1.id = 1001;
    strcpy(r1.name, "TestRecord");
    r1.data_size = 10;
    
    Record r2;
    r2.id = 1002;
    strcpy(r2.name, "SecondRecord");
    r2.data_size = 5;
    
    process_record(&r1);
    process_record(&r2);
    
    printf("R1 ID: %d, R2 ID: %d\\n", r1.id, r2.id);
    
    free(r1.data);
    free(r2.data);
    return 0;
}`,
                question: 'Set a watchpoint on r1.id. Run the program. The watchpoint will trigger when the buffer overflow corrupts memory. What line causes the corruption, and what value is being written to r1.id?',
                hint: 'Use "watch r1.id", "run". The loop in process_record writes one element beyond the allocated array. This may corrupt adjacent memory. When watchpoint triggers, use "bt" to see the call stack and "print i" to see loop variable.',
                answer: 'Line 15 causes corruption when i equals rec->data_size (10 for r1). The statement rec->data[10] writes beyond the allocated array (indices 0-9). The value written depends on heap layout, but the watchpoint shows when r1.id changes unexpectedly due to the overflow.'
            },
            {
                id: 28,
                difficulty: 'hard',
                title: 'Advanced Thread Synchronization',
                code: `#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define NUM_THREADS 5

sem_t semaphore;
int shared_resource = 0;
pthread_barrier_t barrier;

void* worker_thread(void* arg) {
    int id = *(int*)arg;
    
    // Phase 1: All threads reach here together
    printf("Thread %d: Reached barrier\\n", id);
    pthread_barrier_wait(&barrier);
    
    // Phase 2: Controlled access to shared resource
    sem_wait(&semaphore);
    printf("Thread %d: Accessing resource\\n", id);
    shared_resource += id;
    sleep(1);
    printf("Thread %d: Resource value = %d\\n", id, shared_resource);
    sem_post(&semaphore);
    
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int ids[NUM_THREADS];
    
    sem_init(&semaphore, 0, 2);  // Allow 2 threads at a time
    pthread_barrier_init(&barrier, NULL, NUM_THREADS);
    
    for(int i = 0; i < NUM_THREADS; i++) {
        ids[i] = i + 1;
        pthread_create(&threads[i], NULL, worker_thread, &ids[i]);
    }
    
    for(int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    printf("Final resource value: %d\\n", shared_resource);
    
    sem_destroy(&semaphore);
    pthread_barrier_destroy(&barrier);
    return 0;
}`,
                question: 'Set a breakpoint at line 23 (inside semaphore critical section). Run and let it hit. Use "info threads" to see how many threads are currently blocked. What is the semaphore count value, and how many threads can enter the critical section simultaneously?',
                hint: 'Use "break 23", "run". Use "info threads" to see thread states. Use "print semaphore" to examine the semaphore structure. The sem_init initialized it to 2, allowing 2 concurrent accesses.',
                answer: 'The semaphore allows 2 threads simultaneously (initialized with value 2). When breakpoint hits, 2 threads are in the critical section, and 2-3 threads are blocked waiting. Use "print semaphore.__data.__value" to see current semaphore count (will be 0, 1, or 2).'
            },
            {
                id: 29,
                difficulty: 'hard',
                title: 'Cache Line and False Sharing',
                code: `#include <stdio.h>
#include <pthread.h>
#include <stdint.h>

#define NUM_THREADS 4
#define ITERATIONS 10000000

// Deliberately cause false sharing
struct {
    int counter1;
    int counter2;
    int counter3;
    int counter4;
} shared_counters = {0, 0, 0, 0};

void* increment_counter(void* arg) {
    int thread_id = *(int*)arg;
    int *counter;
    
    switch(thread_id) {
        case 0: counter = &shared_counters.counter1; break;
        case 1: counter = &shared_counters.counter2; break;
        case 2: counter = &shared_counters.counter3; break;
        case 3: counter = &shared_counters.counter4; break;
        default: counter = &shared_counters.counter1;
    }
    
    for(int i = 0; i < ITERATIONS; i++) {
        (*counter)++;
    }
    
    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int ids[NUM_THREADS];
    
    for(int i = 0; i < NUM_THREADS; i++) {
        ids[i] = i;
        pthread_create(&threads[i], NULL, increment_counter, &ids[i]);
    }
    
    for(int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    
    printf("Counters: %d %d %d %d\\n", 
           shared_counters.counter1,
           shared_counters.counter2,
           shared_counters.counter3,
           shared_counters.counter4);
    
    return 0;
}`,
                question: 'Set a breakpoint at line 30 (inside the loop). When hit, examine the memory addresses of all four counters. What is the byte offset between counter1 and counter2, and are they on the same cache line (assuming 64-byte cache lines)?',
                hint: 'Use "break 30", "run". Use "print &shared_counters.counter1" through counter4 to get addresses. Subtract addresses to find offsets. If offset < 64 bytes, they share a cache line.',
                answer: 'counter1 and counter2 are 4 bytes apart (sizeof(int)). All four counters fit within 16 bytes, so they are on the same 64-byte cache line. This causes false sharing - each thread modifies its own counter but invalidates others\' caches.'
            },
            {
                id: 30,
                difficulty: 'hard',
                title: 'Reader-Writer Lock Implementation',
                code: `#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
int shared_data = 0;
int read_count = 0;

void* reader_thread(void* arg) {
    int id = *(int*)arg;
    
    for(int i = 0; i < 3; i++) {
        pthread_rwlock_rdlock(&rwlock);
        read_count++;
        printf("Reader %d: data=%d, readers=%d\\n", id, shared_data, read_count);
        usleep(500000);
        read_count--;
        pthread_rwlock_unlock(&rwlock);
        usleep(100000);
    }
    return NULL;
}

void* writer_thread(void* arg) {
    int id = *(int*)arg;
    
    for(int i = 0; i < 2; i++) {
        pthread_rwlock_wrlock(&rwlock);
        shared_data += 10;
        printf("Writer %d: updated data to %d\\n", id, shared_data);
        usleep(800000);
        pthread_rwlock_unlock(&rwlock);
        usleep(200000);
    }
    return NULL;
}

int main() {
    pthread_t readers[4], writers[2];
    int reader_ids[4] = {1, 2, 3, 4};
    int writer_ids[2] = {1, 2};
    
    for(int i = 0; i < 4; i++) {
        pthread_create(&readers[i], NULL, reader_thread, &reader_ids[i]);
    }
    
    for(int i = 0; i < 2; i++) {
        pthread_create(&writers[i], NULL, writer_thread, &writer_ids[i]);
    }
    
    for(int i = 0; i < 4; i++) {
        pthread_join(readers[i], NULL);
    }
    
    for(int i = 0; i < 2; i++) {
        pthread_join(writers[i], NULL);
    }
    
    printf("Final data: %d\\n", shared_data);
    return 0;
}`,
                question: 'Set a breakpoint at line 15 (inside reader critical section). Run until multiple readers are in the critical section simultaneously. Use "thread apply all print read_count" to see read_count in all threads. What is the maximum number of concurrent readers you observe, and examine rwlock structure - what field indicates reader count?',
                hint: 'Use "break 15", "run", "continue" multiple times. Use "info threads" to see active threads. Use "thread apply all bt" to see where each thread is. Multiple readers can hold the lock simultaneously. Check "print rwlock.__data.__nr_readers".',
                answer: 'Multiple readers (2-4) can be in the critical section simultaneously - that\'s the purpose of read-write locks. The rwlock.__data.__nr_readers field shows the current number of active readers. Writers block all readers and other writers.'
            }
        ];

        let currentExercise = null;

        function initializeSidebar() {
            const beginnerDiv = document.getElementById('beginner-exercises');
            const mediumDiv = document.getElementById('medium-exercises');
            const hardDiv = document.getElementById('hard-exercises');

            exercises.forEach(ex => {
                const btn = document.createElement('button');
                btn.className = 'exercise-btn';
                btn.textContent = `${ex.id}. ${ex.title}`;
                btn.onclick = () => loadExercise(ex.id);

                if(ex.difficulty === 'beginner') {
                    beginnerDiv.appendChild(btn);
                } else if(ex.difficulty === 'medium') {
                    mediumDiv.appendChild(btn);
                } else {
                    hardDiv.appendChild(btn);
                }
            });
        }

        function loadExercise(id) {
            currentExercise = exercises.find(ex => ex.id === id);
            if(!currentExercise) return;

            // Update active button
            document.querySelectorAll('.exercise-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.textContent.startsWith(`${id}.`)) {
                    btn.classList.add('active');
                }
            });

            // Hide reveal sections
            document.querySelectorAll('.reveal-section').forEach(section => {
                section.classList.remove('show');
            });

            const contentArea = document.getElementById('content-area');
            contentArea.innerHTML = `
                <div class="exercise-header">
                    <h2 class="exercise-title">${currentExercise.id}. ${currentExercise.title}</h2>
                    <div class="exercise-meta">
                        <span class="badge ${currentExercise.difficulty}">${currentExercise.difficulty}</span>
                        <span class="badge" style="background: #e7f3ff; color: #014361;">Exercise ${currentExercise.id}/30</span>
                    </div>
                </div>

                <div class="code-section">
                    <div class="code-header">
                        <span class="code-label">📝 C Code</span>
                        <button class="copy-btn" onclick="copyCode()">Copy Code</button>
                    </div>
                    <pre><code id="code-display">${highlightCode(currentExercise.code)}</code></pre>
                </div>

                <div class="question-section">
                    <div class="question-label">❓ Debug Challenge</div>
                    <div class="question-text">${currentExercise.question}</div>
                </div>

                <div class="actions">
                    <button class="action-btn hint-btn" onclick="toggleHint()">💡 Show Hint</button>
                    <button class="action-btn answer-btn" onclick="toggleAnswer()">✓ Show Answer</button>
                </div>

                <div class="reveal-section hint" id="hint-section">
                    <div class="reveal-header">💡 Hint</div>
                    <div class="reveal-content">${currentExercise.hint}</div>
                </div>

                <div class="reveal-section answer" id="answer-section">
                    <div class="reveal-header">✓ Answer & Explanation</div>
                    <div class="reveal-content">${currentExercise.answer}</div>
                </div>
            `;
        }

        function highlightCode(code) {
            // Don't escape yet - work with raw code
            // Apply highlighting first, THEN the result will be safe HTML
            
            // Strings first (to avoid highlighting keywords inside strings)
            code = code.replace(/"([^"\\]|\\.)*"/g, match => {
                return '<span class="string">' + match.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;') + '</span>';
            });
            
            // Comments
            code = code.replace(/\/\/.*$/gm, match => {
                return '<span class="comment">' + match.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;') + '</span>';
            });
            
            code = code.replace(/\/\*[\s\S]*?\*\//g, match => {
                return '<span class="comment">' + match.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;') + '</span>';
            });
            
            // Preprocessor directives
            code = code.replace(/#.*$/gm, match => {
                return '<span class="comment">' + match.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;') + '</span>';
            });
            
            // Now escape the rest of the content (not inside spans)
            code = code.replace(/([^>])([^<]+?)(?=<|$)/g, (match, prefix, content) => {
                let escaped = content
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                // Keywords
                escaped = escaped.replace(/\b(int|void|char|float|double|struct|typedef|return|if|else|for|while|switch|case|break|continue|const|static|unsigned|long|short|sizeof|pthread_t|pthread_mutex_t|pthread_cond_t|sem_t|pthread_rwlock_t|pthread_barrier_t|__thread|NULL)\b/g, '<span class="keyword">$1</span>');
                
                // Function calls
                escaped = escaped.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?=\()/g, (m, funcName) => {
                    if (['if', 'for', 'while', 'switch', 'return', 'sizeof'].includes(funcName)) return m;
                    return '<span class="function">' + funcName + '</span>';
                });
                
                // Numbers
                escaped = escaped.replace(/\b(0x[0-9A-Fa-f]+|[0-9]+)\b/g, '<span class="number">$1</span>');
                
                return prefix + escaped;
            });
            
            return code;
        }

        function copyCode() {
            const code = currentExercise.code;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✓ Copied!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#61dafb';
                }, 2000);
            });
        }

        function toggleHint() {
            const hintSection = document.getElementById('hint-section');
            hintSection.classList.toggle('show');
        }

        function toggleAnswer() {
            const answerSection = document.getElementById('answer-section');
            answerSection.classList.toggle('show');
        }

        // Initialize on load
        initializeSidebar();
    </script>
</body>
</html>